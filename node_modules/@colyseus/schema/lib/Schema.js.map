{"version":3,"file":"Schema.js","sourceRoot":"","sources":["../src/Schema.ts"],"names":[],"mappings":"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","sourcesContent":["import { OPERATION } from './encoding/spec';\nimport { DEFAULT_VIEW_TAG, type DefinitionType } from \"./annotations\";\n\nimport { AssignableProps, NonFunctionPropNames, ToJSON } from './types/HelperTypes';\n\nimport { ChangeSet, ChangeSetName, ChangeTree, IRef, Ref } from './encoder/ChangeTree';\nimport { $changes, $decoder, $deleteByIndex, $descriptors, $encoder, $filter, $getByIndex, $track } from './types/symbols';\nimport { StateView } from './encoder/StateView';\n\nimport { encodeSchemaOperation } from './encoder/EncodeOperation';\nimport { decodeSchemaOperation } from './decoder/DecodeOperation';\n\nimport type { Decoder } from './decoder/Decoder';\nimport type { Metadata, MetadataField } from './Metadata';\nimport { getIndent } from './utils';\n\n/**\n * Schema encoder / decoder\n */\nexport class Schema<C = any> implements IRef {\n    static [Symbol.metadata]: Metadata;\n    static [$encoder] = encodeSchemaOperation;\n    static [$decoder] = decodeSchemaOperation;\n\n    /**\n     * Assign the property descriptors required to track changes on this instance.\n     * @param instance\n     */\n    static initialize(instance: any) {\n        Object.defineProperty(instance, $changes, {\n            value: new ChangeTree(instance),\n            enumerable: false,\n            writable: true\n        });\n\n        Object.defineProperties(instance, instance.constructor[Symbol.metadata]?.[$descriptors] || {});\n    }\n\n    static is(type: DefinitionType) {\n        return typeof((type as typeof Schema)[Symbol.metadata]) === \"object\";\n    }\n\n    /**\n     * Track property changes\n     */\n    static [$track] (changeTree: ChangeTree, index: number, operation: OPERATION = OPERATION.ADD) {\n        changeTree.change(index, operation);\n    }\n\n    /**\n     * Determine if a property must be filtered.\n     * - If returns false, the property is NOT going to be encoded.\n     * - If returns true, the property is going to be encoded.\n     *\n     * Encoding with \"filters\" happens in two steps:\n     * - First, the encoder iterates over all \"not owned\" properties and encodes them.\n     * - Then, the encoder iterates over all \"owned\" properties per instance and encodes them.\n     */\n    static [$filter] (ref: Schema, index: number, view: StateView) {\n        const metadata: Metadata = (ref.constructor as typeof Schema)[Symbol.metadata];\n        const tag = metadata[index]?.tag;\n\n        if (view === undefined) {\n            // shared pass/encode: encode if doesn't have a tag\n            return tag === undefined;\n\n        } else if (tag === undefined) {\n            // view pass: no tag\n            return true;\n\n        } else if (tag === DEFAULT_VIEW_TAG) {\n            // view pass: default tag\n            return view.isChangeTreeVisible(ref[$changes]);\n\n        } else {\n            // view pass: custom tag\n            const tags = view.tags?.get(ref[$changes]);\n            return tags && tags.has(tag);\n        }\n    }\n\n    // allow inherited classes to have a constructor\n    constructor(arg?: C) {\n        //\n        // inline\n        // Schema.initialize(this);\n        //\n        Schema.initialize(this);\n\n        //\n        // Assign initial values\n        //\n        if (arg) {\n            Object.assign(this, arg);\n        }\n    }\n\n    public assign<T extends Partial<this>>(\n        props: AssignableProps<T>,\n    ): this {\n        Object.assign(this, props);\n        return this;\n    }\n\n    /**\n     * (Server-side): Flag a property to be encoded for the next patch.\n     * @param instance Schema instance\n     * @param property string representing the property name, or number representing the index of the property.\n     * @param operation OPERATION to perform (detected automatically)\n     */\n    public setDirty<K extends NonFunctionPropNames<this>>(property: K | number, operation?: OPERATION) {\n        const metadata: Metadata = (this.constructor as typeof Schema)[Symbol.metadata];\n        this[$changes].change(\n            metadata[metadata[property as string]].index,\n            operation\n        );\n    }\n\n    clone (): this {\n        // Create instance without calling custom constructor\n        const cloned = Object.create(this.constructor.prototype);\n        Schema.initialize(cloned);\n\n        const metadata: Metadata = (this.constructor as typeof Schema)[Symbol.metadata];\n\n        //\n        // TODO: clone all properties, not only annotated ones\n        //\n        // for (const field in this) {\n        for (const fieldIndex in metadata) {\n            const field = metadata[fieldIndex as any as number].name as keyof this;\n\n            if (\n                typeof (this[field]) === \"object\" &&\n                typeof ((this[field] as any)?.clone) === \"function\"\n            ) {\n                // deep clone\n                cloned[field] = (this[field] as any).clone();\n\n            } else {\n                // primitive values\n                cloned[field] = this[field];\n            }\n        }\n\n        return cloned;\n    }\n\n    toJSON (this: any): ToJSON<this> {\n        const obj: any = {};\n        const metadata = this.constructor[Symbol.metadata];\n        for (const index in metadata) {\n            const field = metadata[index] as MetadataField;\n            const fieldName = field.name;\n            if (!field.deprecated && this[fieldName] !== null && typeof (this[fieldName]) !== \"undefined\") {\n                obj[fieldName] = (typeof (this[fieldName]['toJSON']) === \"function\")\n                    ? this[fieldName]['toJSON']()\n                    : this[fieldName];\n            }\n        }\n        return obj;\n    }\n\n    /**\n     * Used in tests only\n     * @internal\n     */\n    discardAllChanges() {\n        this[$changes].discardAll();\n    }\n\n    [$getByIndex](index: number): any {\n        const metadata: Metadata = (this.constructor as typeof Schema)[Symbol.metadata];\n        return this[metadata[index].name as keyof this];\n    }\n\n    [$deleteByIndex](index: number): void {\n        const metadata: Metadata = (this.constructor as typeof Schema)[Symbol.metadata];\n        this[metadata[index].name as keyof this] = undefined;\n    }\n\n    /**\n     * Inspect the `refId` of all Schema instances in the tree. Optionally display the contents of the instance.\n     *\n     * @param ref Schema instance\n     * @param showContents display JSON contents of the instance\n     * @returns\n     */\n    static debugRefIds<T extends Schema>(ref: T, showContents: boolean = false, level: number = 0, decoder?: Decoder, keyPrefix: string = \"\") {\n        const contents = (showContents) ? ` - ${JSON.stringify(ref.toJSON())}` : \"\";\n        const changeTree: ChangeTree = ref[$changes];\n\n        const refId = (decoder) ? decoder.root.refIds.get(ref) : changeTree.refId;\n        const root = (decoder) ? decoder.root : changeTree.root;\n\n         // log reference count if > 1\n        const refCount = (root?.refCount?.[refId] > 1)\n            ? ` [Ã—${root.refCount[refId]}]`\n            : '';\n\n        let output = `${getIndent(level)}${keyPrefix}${ref.constructor.name} (refId: ${refId})${refCount}${contents}\\n`;\n\n        changeTree.forEachChild((childChangeTree, indexOrKey) => {\n            let key = indexOrKey;\n            if (typeof indexOrKey === 'number' && (ref as any)['$indexes']) {\n                // MapSchema\n                key = (ref as any)['$indexes'].get(indexOrKey) ?? indexOrKey;\n            }\n            const keyPrefix = ((ref as any)['forEach'] !== undefined && key !== undefined) ? `[\"${key}\"]: ` : \"\";\n            output += this.debugRefIds(childChangeTree.ref, showContents, level + 1, decoder, keyPrefix);\n        });\n\n        return output;\n    }\n\n    static debugRefIdEncodingOrder<T extends Ref>(ref: T, changeSet: ChangeSetName = 'allChanges') {\n        let encodeOrder: number[] = [];\n        let current = ref[$changes].root[changeSet].next;\n        while (current) {\n            if (current.changeTree) {\n                encodeOrder.push(current.changeTree.refId);\n            }\n            current = current.next;\n        }\n        return encodeOrder;\n    }\n\n    static debugRefIdsFromDecoder(decoder: Decoder) {\n        return this.debugRefIds(decoder.state, false, 0, decoder);\n    }\n\n    /**\n     * Return a string representation of the changes on a Schema instance.\n     * The list of changes is cleared after each encode.\n     *\n     * @param instance Schema instance\n     * @param isEncodeAll Return \"full encode\" instead of current change set.\n     * @returns\n     */\n    static debugChanges<T extends Ref>(instance: T, isEncodeAll: boolean = false) {\n        const changeTree: ChangeTree = instance[$changes];\n\n        const changeSet = (isEncodeAll) ? changeTree.allChanges : changeTree.changes;\n        const changeSetName = (isEncodeAll) ? \"allChanges\" : \"changes\";\n\n        let output = `${instance.constructor.name} (${changeTree.refId}) -> .${changeSetName}:\\n`;\n\n        function dumpChangeSet(changeSet: ChangeSet) {\n            changeSet.operations\n                .filter(op => op)\n                .forEach((index) => {\n                    const operation = changeTree.indexedOperations[index];\n                    output += `- [${index}]: ${OPERATION[operation]} (${JSON.stringify(changeTree.getValue(Number(index), isEncodeAll))})\\n`\n                });\n        }\n\n        dumpChangeSet(changeSet);\n\n        // display filtered changes\n        if (\n            !isEncodeAll &&\n            changeTree.filteredChanges &&\n            (changeTree.filteredChanges.operations).filter(op => op).length > 0\n        ) {\n            output += `${instance.constructor.name} (${changeTree.refId}) -> .filteredChanges:\\n`;\n            dumpChangeSet(changeTree.filteredChanges);\n        }\n\n        // display filtered changes\n        if (\n            isEncodeAll &&\n            changeTree.allFilteredChanges &&\n            (changeTree.allFilteredChanges.operations).filter(op => op).length > 0\n        ) {\n            output += `${instance.constructor.name} (${changeTree.refId}) -> .allFilteredChanges:\\n`;\n            dumpChangeSet(changeTree.allFilteredChanges);\n        }\n\n        return output;\n    }\n\n    static debugChangesDeep<T extends Schema>(ref: T, changeSetName: \"changes\" | \"allChanges\" | \"allFilteredChanges\" | \"filteredChanges\" = \"changes\") {\n        let output = \"\";\n\n        const rootChangeTree: ChangeTree = ref[$changes];\n        const root = rootChangeTree.root;\n        const changeTrees: Map<ChangeTree, ChangeTree[]> = new Map();\n\n        const instanceRefIds = [];\n        let totalOperations = 0;\n\n        // TODO: FIXME: this method is not working as expected\n        for (const [refId, changes] of Object.entries(root[changeSetName])) {\n            const changeTree = root.changeTrees[refId as any as number];\n            if (!changeTree) { continue; }\n\n            let includeChangeTree = false;\n            let parentChangeTrees: ChangeTree[] = [];\n            let parentChangeTree = changeTree.parent?.[$changes];\n\n            if (changeTree === rootChangeTree) {\n                includeChangeTree = true;\n\n            } else {\n                while (parentChangeTree !== undefined) {\n                    parentChangeTrees.push(parentChangeTree);\n                    if (parentChangeTree.ref === ref) {\n                        includeChangeTree = true;\n                        break;\n                    }\n                    parentChangeTree = parentChangeTree.parent?.[$changes];\n                }\n            }\n\n            if (includeChangeTree) {\n                instanceRefIds.push(changeTree.refId);\n                totalOperations += Object.keys(changes).length;\n                changeTrees.set(changeTree, parentChangeTrees.reverse());\n            }\n        }\n\n        output += \"---\\n\"\n        output += `root refId: ${rootChangeTree.refId}\\n`;\n        output += `Total instances: ${instanceRefIds.length} (refIds: ${instanceRefIds.join(\", \")})\\n`;\n        output += `Total changes: ${totalOperations}\\n`;\n        output += \"---\\n\"\n\n        // based on root.changes, display a tree of changes that has the \"ref\" instance as parent\n        const visitedParents = new WeakSet<ChangeTree>();\n        for (const [changeTree, parentChangeTrees] of changeTrees.entries()) {\n            parentChangeTrees.forEach((parentChangeTree, level) => {\n                if (!visitedParents.has(parentChangeTree)) {\n                    output += `${getIndent(level)}${parentChangeTree.ref.constructor.name} (refId: ${parentChangeTree.refId})\\n`;\n                    visitedParents.add(parentChangeTree);\n                }\n            });\n\n            const changes = changeTree.indexedOperations;\n            const level = parentChangeTrees.length;\n            const indent = getIndent(level);\n\n            const parentIndex = (level > 0) ? `(${changeTree.parentIndex}) ` : \"\";\n            output += `${indent}${parentIndex}${changeTree.ref.constructor.name} (refId: ${changeTree.refId}) - changes: ${Object.keys(changes).length}\\n`;\n\n            for (const index in changes) {\n                const operation = changes[index];\n                output += `${getIndent(level + 1)}${OPERATION[operation]}: ${index}\\n`;\n            }\n        }\n\n        return `${output}`;\n    }\n\n\n}\n\n"]}
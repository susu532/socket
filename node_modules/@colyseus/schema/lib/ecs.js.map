{"version":3,"file":"ecs.js","sourceRoot":"","sources":["../src/ecs.ts"],"names":[],"mappings":"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","sourcesContent":["import { component, field, system, System, World } from '@lastolivegames/becsy';\nimport readline from \"readline\";\nimport { Readable } from 'stream';\nimport { $decoder, $encoder, $track } from './types/symbols';\nimport { encodeSchemaOperation } from './encoder/EncodeOperation';\nimport { decodeSchemaOperation } from './decoder/DecodeOperation';\nimport { ChangeTree } from './encoder/ChangeTree';\nimport { OPERATION } from './encoding/spec';\nimport { Metadata } from './Metadata';\n\n@component class Position {\n    @field.float64 declare x: number;\n    @field.float64 declare y: number;\n}\n\n@component class Velocity {\n    @field.float64 declare vx: number;\n    @field.float64 declare vy: number;\n}\n\n@system export class VelocityInputController extends System {\n    // Every system can define any number of queries whose results will be available in the `execute`\n    // method.  In this case, we're asking for all entities that currently have a Velocity component,\n    // and declare that we'll be writing to those components.\n    private readonly movables = this.query(q => q.current.with(Velocity).write);\n\n    // Here we'll store all keys that are currently pressed.  This is not specific to ECS but it's a\n    // common pattern to glue together event-driven (DOM) and timing-driven (ECS) processes.\n    private readonly keysPressed = new Set<string>();\n\n    // Every system can provide an `initialize` method that will be called once as the world is being\n    // set up.  We'll use it to register our DOM event handlers.\n    initialize(): void {\n        // Listen for keypress events\n        const timeouts: {[key: string]: NodeJS.Timeout} = {};\n\n        process.stdin.on('keypress', (str, key) => {\n            if (key.ctrl && key.name === 'c') {\n                // If Ctrl+C is pressed, exit the program\n                rl.close();\n\n            } else {\n                // Print the key pressed\n                this.keysPressed.add(key.name);\n\n                if (timeouts[key.name]) {\n                    clearTimeout(timeouts[key.name]);\n                }\n\n                timeouts[key.name] = setTimeout(() => {\n                    this.keysPressed.delete(key.name);\n                    delete timeouts[key.name];\n                }, 100);\n            }\n        });\n    }\n\n    // Every system can (and probably should) provide an `execute` method that implements its logic.\n    // It will be invoked once per frame in our demo, so at 60fps it's called 60 times per second.\n    execute(): void {\n        // We loop through the query results of the movables query we defined above.\n        for (const movable of this.movables.current) {\n            // This is how we access the data stored in the Velocity component of our movable entity.\n            // We must specify whether we intend to only `read` the data or also to `write` it.  We'll\n            // only be allowed to `write` to component types that we reserved as such in our queries.\n            const velocity = movable.write(Velocity);\n\n            if (this.keysPressed.has('up')) velocity.vy = -100;  // in pixels per second\n            else if (this.keysPressed.has('down')) velocity.vy = 100;\n            else velocity.vy = 0;\n\n            if (this.keysPressed.has('left')) velocity.vx = -100;\n            else if (this.keysPressed.has('right')) velocity.vx = 100;\n            else velocity.vx = 0;\n        }\n    }\n}\n\n@system export class Movement extends System {\n    private readonly movables =\n        this.query(q => q.current.with(Velocity).and.with(Position).write);\n\n    execute(): void {\n        for (const movable of this.movables.current) {\n            // We retrive both velocity (to read) and position (to write) from our entities.\n            const velocity = movable.read(Velocity);\n            const position = movable.write(Position);\n            // In the execute method, a system has access to `this.delta`, which is the delta time between\n            // the current frame and the previous one.  This allows us to calculate a stable movement\n            // regardless of the intervals between our frames.  For more on that see\n            // https://drewcampbell92.medium.com/understanding-delta-time-b53bf4781a03.\n            position.x += this.delta * velocity.vx;\n            position.y += this.delta * velocity.vy;\n            console.log(\"x:\", position.x, \"y:\", position.y);\n        }\n    }\n}\n\nMetadata.setFields(World, {\n    x: \"number\",\n    y: \"number\",\n    z: \"number\",\n});\n\nWorld[$encoder] = encodeSchemaOperation;\nWorld[$decoder] = decodeSchemaOperation;\nWorld[$track] = function (\n    changeTree: ChangeTree,\n    index: number,\n    operation: OPERATION = OPERATION.ADD\n) {\n    changeTree.change(index, operation);\n};\n\nasync function main() {\n    // We can now create the world that all our entities and their components will live in.  All system\n    // and component classes tagged with `@system` and `@component` will be automatically added to the\n    // world's `defs`, and in this case we don't need to add any other types manually.\n    const world = await World.create();\n\n    // Now we create the entity that will represent our object and add the components it will need.\n    // Each component type can be optionally followed by an object with initial field values.\n    world.createEntity(Position, Velocity);\n\n    // Finally, we set up our game loop.  The `run` function will be executed once per frame.\n    async function run() {\n        // Execute the world, which will call the `execute` method of all systems in sequence.  The call\n        // is asynchronous and we _must_ await its result, otherwise errors won't be reported properly.\n        await world.execute();\n    }\n\n    setInterval(() => run(), 1000 / 30);\n}\n\nmain();\n\n// Create an interface for reading input\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout\n});\n\n// Start listening for input\nprocess.stdin.setRawMode(true);\nprocess.stdin.resume();"]}
{"version":3,"file":"annotations.js","sourceRoot":"","sources":["../src/annotations.ts"],"names":[],"mappings":"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","sourcesContent":["import \"./symbol.shim\";\nimport { Schema } from './Schema';\nimport { ArraySchema } from './types/custom/ArraySchema';\nimport { MapSchema } from './types/custom/MapSchema';\nimport { getNormalizedType, Metadata } from \"./Metadata\";\nimport { $changes, $childType, $descriptors, $numFields, $track } from \"./types/symbols\";\nimport { TypeDefinition, getType } from \"./types/registry\";\nimport { OPERATION } from \"./encoding/spec\";\nimport { TypeContext } from \"./types/TypeContext\";\nimport { assertInstanceType, assertType } from \"./encoding/assert\";\nimport type { InferValueType, InferSchemaInstanceType, AssignableProps, IsNever } from \"./types/HelperTypes\";\nimport { CollectionSchema } from \"./types/custom/CollectionSchema\";\nimport { SetSchema } from \"./types/custom/SetSchema\";\n\nexport type RawPrimitiveType = \"string\" |\n    \"number\" |\n    \"boolean\" |\n    \"int8\" |\n    \"uint8\" |\n    \"int16\" |\n    \"uint16\" |\n    \"int32\" |\n    \"uint32\" |\n    \"int64\" |\n    \"uint64\" |\n    \"float32\" |\n    \"float64\" |\n    \"bigint64\" |\n    \"biguint64\";\n\nexport type PrimitiveType = RawPrimitiveType | typeof Schema | object;\n\n// TODO: infer \"default\" value type correctly.\nexport type DefinitionType<T extends PrimitiveType = PrimitiveType> = T\n    | T[]\n    | { type: T, default?: InferValueType<T>, view?: boolean | number }\n    | { array: T, default?: ArraySchema<InferValueType<T>>, view?: boolean | number }\n    | { map: T, default?: MapSchema<InferValueType<T>>, view?: boolean | number }\n    | { collection: T, default?: CollectionSchema<InferValueType<T>>, view?: boolean | number }\n    | { set: T, default?: SetSchema<InferValueType<T>>, view?: boolean | number };\n\nexport type Definition = { [field: string]: DefinitionType };\n\nexport interface TypeOptions {\n    manual?: boolean,\n}\n\nexport const DEFAULT_VIEW_TAG = -1;\n\nexport function entity(constructor: any): any {\n    TypeContext.register(constructor as typeof Schema);\n    return constructor;\n}\n\n/**\n * [See documentation](https://docs.colyseus.io/state/schema/)\n *\n * Annotate a Schema property to be serializeable.\n * \\@type()'d fields are automatically flagged as \"dirty\" for the next patch.\n *\n * @example Standard usage, with automatic change tracking.\n * ```\n * \\@type(\"string\") propertyName: string;\n * ```\n *\n * @example You can provide the \"manual\" option if you'd like to manually control your patches via .setDirty().\n * ```\n * \\@type(\"string\", { manual: true })\n * ```\n */\n// export function type(type: DefinitionType, options?: TypeOptions) {\n//     return function ({ get, set }, context: ClassAccessorDecoratorContext): ClassAccessorDecoratorResult<Schema, any> {\n//         if (context.kind !== \"accessor\") {\n//             throw new Error(\"@type() is only supported for class accessor properties\");\n//         }\n\n//         const field = context.name.toString();\n\n//         //\n//         // detect index for this field, considering inheritance\n//         //\n//         const parent = Object.getPrototypeOf(context.metadata);\n//         let fieldIndex: number = context.metadata[$numFields] // current structure already has fields defined\n//             ?? (parent && parent[$numFields]) // parent structure has fields defined\n//             ?? -1; // no fields defined\n//         fieldIndex++;\n\n//         if (\n//             !parent && // the parent already initializes the `$changes` property\n//             !Metadata.hasFields(context.metadata)\n//         ) {\n//             context.addInitializer(function (this: Ref) {\n//                 Object.defineProperty(this, $changes, {\n//                     value: new ChangeTree(this),\n//                     enumerable: false,\n//                     writable: true\n//                 });\n//             });\n//         }\n\n//         Metadata.addField(context.metadata, fieldIndex, field, type);\n\n//         const isArray = ArraySchema.is(type);\n//         const isMap = !isArray && MapSchema.is(type);\n\n//         // if (options && options.manual) {\n//         //     // do not declare getter/setter descriptor\n//         //     definition.descriptors[field] = {\n//         //         enumerable: true,\n//         //         configurable: true,\n//         //         writable: true,\n//         //     };\n//         //     return;\n//         // }\n\n//         return {\n//             init(value) {\n//                 // TODO: may need to convert ArraySchema/MapSchema here\n\n//                 // do not flag change if value is undefined.\n//                 if (value !== undefined) {\n//                     this[$changes].change(fieldIndex);\n\n//                     // automaticallty transform Array into ArraySchema\n//                     if (isArray) {\n//                         if (!(value instanceof ArraySchema)) {\n//                             value = new ArraySchema(...value);\n//                         }\n//                         value[$childType] = Object.values(type)[0];\n//                     }\n\n//                     // automaticallty transform Map into MapSchema\n//                     if (isMap) {\n//                         if (!(value instanceof MapSchema)) {\n//                             value = new MapSchema(value);\n//                         }\n//                         value[$childType] = Object.values(type)[0];\n//                     }\n\n//                     // try to turn provided structure into a Proxy\n//                     if (value['$proxy'] === undefined) {\n//                         if (isMap) {\n//                             value = getMapProxy(value);\n//                         }\n//                     }\n\n//                 }\n\n//                 return value;\n//             },\n\n//             get() {\n//                 return get.call(this);\n//             },\n\n//             set(value: any) {\n//                 /**\n//                  * Create Proxy for array or map items\n//                  */\n\n//                 // skip if value is the same as cached.\n//                 if (value === get.call(this)) {\n//                     return;\n//                 }\n\n//                 if (\n//                     value !== undefined &&\n//                     value !== null\n//                 ) {\n//                     // automaticallty transform Array into ArraySchema\n//                     if (isArray) {\n//                         if (!(value instanceof ArraySchema)) {\n//                             value = new ArraySchema(...value);\n//                         }\n//                         value[$childType] = Object.values(type)[0];\n//                     }\n\n//                     // automaticallty transform Map into MapSchema\n//                     if (isMap) {\n//                         if (!(value instanceof MapSchema)) {\n//                             value = new MapSchema(value);\n//                         }\n//                         value[$childType] = Object.values(type)[0];\n//                     }\n\n//                     // try to turn provided structure into a Proxy\n//                     if (value['$proxy'] === undefined) {\n//                         if (isMap) {\n//                             value = getMapProxy(value);\n//                         }\n//                     }\n\n//                     // flag the change for encoding.\n//                     this[$changes].change(fieldIndex);\n\n//                     //\n//                     // call setParent() recursively for this and its child\n//                     // structures.\n//                     //\n//                     if (value[$changes]) {\n//                         value[$changes].setParent(\n//                             this,\n//                             this[$changes].root,\n//                             Metadata.getIndex(context.metadata, field),\n//                         );\n//                     }\n\n//                 } else if (get.call(this)) {\n//                     //\n//                     // Setting a field to `null` or `undefined` will delete it.\n//                     //\n//                     this[$changes].delete(field);\n//                 }\n\n//                 set.call(this, value);\n//             },\n//         };\n//     }\n// }\n\nexport function view<T> (tag: number = DEFAULT_VIEW_TAG) {\n    return function(target: T, fieldName: string) {\n        const constructor = target.constructor as typeof Schema;\n\n        const parentClass = Object.getPrototypeOf(constructor);\n        const parentMetadata = parentClass[Symbol.metadata];\n\n        // TODO: use Metadata.initialize()\n        const metadata: Metadata = (constructor[Symbol.metadata] ??= Object.assign({}, constructor[Symbol.metadata], parentMetadata ?? Object.create(null)));\n        // const fieldIndex = metadata[fieldName];\n\n        // if (!metadata[fieldIndex]) {\n        //     //\n        //     // detect index for this field, considering inheritance\n        //     //\n        //     metadata[fieldIndex] = {\n        //         type: undefined,\n        //         index: (metadata[$numFields] // current structure already has fields defined\n        //             ?? (parentMetadata && parentMetadata[$numFields]) // parent structure has fields defined\n        //             ?? -1) + 1 // no fields defined\n        //     }\n        // }\n\n        Metadata.setTag(metadata, fieldName, tag);\n    }\n}\n\nexport function unreliable<T> (target: T, field: string) {\n    //\n    // FIXME: the following block of code is repeated across `@type()`, `@deprecated()` and `@unreliable()` decorators.\n    //\n    const constructor = target.constructor as typeof Schema;\n\n    const parentClass = Object.getPrototypeOf(constructor);\n    const parentMetadata = parentClass[Symbol.metadata];\n\n    // TODO: use Metadata.initialize()\n    const metadata: Metadata = (constructor[Symbol.metadata] ??= Object.assign({}, constructor[Symbol.metadata], parentMetadata ?? Object.create(null)));\n\n    // if (!metadata[field]) {\n    //     //\n    //     // detect index for this field, considering inheritance\n    //     //\n    //     metadata[field] = {\n    //         type: undefined,\n    //         index: (metadata[$numFields] // current structure already has fields defined\n    //             ?? (parentMetadata && parentMetadata[$numFields]) // parent structure has fields defined\n    //             ?? -1) + 1 // no fields defined\n    //     }\n    // }\n\n    // add owned flag to the field\n    metadata[metadata[field]].unreliable = true;\n}\n\nexport function type (\n    type: DefinitionType,\n    options?: TypeOptions\n): PropertyDecorator {\n    return function (target: typeof Schema, field: string) {\n        const constructor = target.constructor as typeof Schema;\n\n        if (!type) {\n            throw new Error(`${constructor.name}: @type() reference provided for \"${field}\" is undefined. Make sure you don't have any circular dependencies.`);\n        }\n\n        // Normalize type (enum/collection/etc)\n        type = getNormalizedType(type);\n\n        // for inheritance support\n        TypeContext.register(constructor);\n\n        const parentClass = Object.getPrototypeOf(constructor);\n        const parentMetadata =  parentClass[Symbol.metadata];\n        const metadata = Metadata.initialize(constructor);\n\n        let fieldIndex: number = metadata[field];\n\n        /**\n         * skip if descriptor already exists for this field (`@deprecated()`)\n         */\n        if (metadata[fieldIndex] !== undefined) {\n            if (metadata[fieldIndex].deprecated) {\n                // do not create accessors for deprecated properties.\n                return;\n\n            } else if (metadata[fieldIndex].type !== undefined) {\n                // trying to define same property multiple times across inheritance.\n                // https://github.com/colyseus/colyseus-unity3d/issues/131#issuecomment-814308572\n                try {\n                    throw new Error(`@colyseus/schema: Duplicate '${field}' definition on '${constructor.name}'.\\nCheck @type() annotation`);\n\n                } catch (e) {\n                    const definitionAtLine = e.stack.split(\"\\n\")[4].trim();\n                    throw new Error(`${e.message} ${definitionAtLine}`);\n                }\n            }\n\n        } else {\n            //\n            // detect index for this field, considering inheritance\n            //\n            fieldIndex = metadata[$numFields] // current structure already has fields defined\n                ?? (parentMetadata && parentMetadata[$numFields]) // parent structure has fields defined\n                ?? -1; // no fields defined\n            fieldIndex++;\n        }\n\n        if (options && options.manual) {\n            Metadata.addField(\n                metadata,\n                fieldIndex,\n                field,\n                type,\n                {\n                    // do not declare getter/setter descriptor\n                    enumerable: true,\n                    configurable: true,\n                    writable: true,\n                }\n            );\n\n        } else {\n            const complexTypeKlass = typeof(Object.keys(type)[0]) === \"string\" && getType(Object.keys(type)[0]);\n\n            const childType = (complexTypeKlass)\n                ? Object.values(type)[0]\n                : type;\n\n            Metadata.addField(\n                metadata,\n                fieldIndex,\n                field,\n                type,\n                getPropertyDescriptor(`_${field}`, fieldIndex, childType, complexTypeKlass)\n            );\n        }\n    }\n}\n\nexport function getPropertyDescriptor(\n    fieldCached: string,\n    fieldIndex: number,\n    type: DefinitionType,\n    complexTypeKlass: TypeDefinition,\n) {\n    return {\n        get: function (this: Schema) { return this[fieldCached as keyof Schema]; },\n        set: function (this: Schema, value: any) {\n            const previousValue = this[fieldCached as keyof Schema] ?? undefined;\n\n            // skip if value is the same as cached.\n            if (value === previousValue) { return; }\n\n            if (\n                value !== undefined &&\n                value !== null\n            ) {\n                if (complexTypeKlass) {\n                    // automaticallty transform Array into ArraySchema\n                    if (complexTypeKlass.constructor === ArraySchema && !(value instanceof ArraySchema)) {\n                        value = new ArraySchema(...value);\n                    }\n\n                    // automaticallty transform Map into MapSchema\n                    if (complexTypeKlass.constructor === MapSchema && !(value instanceof MapSchema)) {\n                        value = new MapSchema(value);\n                    }\n\n                    // // automaticallty transform Array into SetSchema\n                    // if (complexTypeKlass.constructor === SetSchema && !(value instanceof SetSchema)) {\n                    //     value = new SetSchema(value);\n                    // }\n\n                    value[$childType] = type;\n\n                } else if (typeof (type) !== \"string\") {\n                    assertInstanceType(value, type as typeof Schema, this, fieldCached.substring(1));\n\n                } else {\n                    assertType(value, type, this, fieldCached.substring(1));\n                }\n\n                const changeTree = this[$changes];\n\n                //\n                // Replacing existing \"ref\", remove it from root.\n                //\n                if (previousValue !== undefined && previousValue[$changes]) {\n                    changeTree.root?.remove(previousValue[$changes]);\n                    (this.constructor as typeof Schema)[$track](changeTree, fieldIndex, OPERATION.DELETE_AND_ADD);\n\n                } else {\n                    (this.constructor as typeof Schema)[$track](changeTree, fieldIndex, OPERATION.ADD);\n                }\n\n                //\n                // call setParent() recursively for this and its child\n                // structures.\n                //\n                value[$changes]?.setParent(this, changeTree.root, fieldIndex);\n\n            } else if (previousValue !== undefined) {\n                //\n                // Setting a field to `null` or `undefined` will delete it.\n                //\n                this[$changes].delete(fieldIndex);\n            }\n\n            this[fieldCached as keyof Schema] = value;\n        },\n\n        enumerable: true,\n        configurable: true\n    };\n}\n\n/**\n * `@deprecated()` flag a field as deprecated.\n * The previous `@type()` annotation should remain along with this one.\n */\n\nexport function deprecated(throws: boolean = true): PropertyDecorator {\n    return function (klass: typeof Schema, field: string) {\n        //\n        // FIXME: the following block of code is repeated across `@type()`, `@deprecated()` and `@unreliable()` decorators.\n        //\n        const constructor = klass.constructor as typeof Schema;\n\n        const parentClass = Object.getPrototypeOf(constructor);\n        const parentMetadata = parentClass[Symbol.metadata];\n        const metadata: Metadata = (constructor[Symbol.metadata] ??= Object.assign({}, constructor[Symbol.metadata], parentMetadata ?? Object.create(null)));\n        const fieldIndex = metadata[field];\n\n        // if (!metadata[field]) {\n        //     //\n        //     // detect index for this field, considering inheritance\n        //     //\n        //     metadata[field] = {\n        //         type: undefined,\n        //         index: (metadata[$numFields] // current structure already has fields defined\n        //             ?? (parentMetadata && parentMetadata[$numFields]) // parent structure has fields defined\n        //             ?? -1) + 1 // no fields defined\n        //     }\n        // }\n\n        metadata[fieldIndex].deprecated = true;\n\n        if (throws) {\n            metadata[$descriptors] ??= {};\n            metadata[$descriptors][field] = {\n                get: function () { throw new Error(`${field} is deprecated.`); },\n                set: function (this: Schema, value: any) { /* throw new Error(`${field} is deprecated.`); */ },\n                enumerable: false,\n                configurable: true\n            };\n        }\n\n        // flag metadata[field] as non-enumerable\n        Object.defineProperty(metadata, fieldIndex, {\n            value: metadata[fieldIndex],\n            enumerable: false,\n            configurable: true\n        });\n    }\n}\n\nexport function defineTypes(\n    target: typeof Schema,\n    fields: Definition,\n    options?: TypeOptions\n) {\n    for (let field in fields) {\n        type(fields[field], options)(target.prototype, field);\n    }\n    return target;\n}\n\n// Helper type to extract InitProps from initialize method\n// Supports both single object parameter and multiple parameters\n// If no initialize method is specified, use AssignableProps for field initialization\ntype ExtractInitProps<T> = T extends { initialize: (...args: infer P) => void }\n    ? P extends readonly []\n        ? never\n        : P extends readonly [infer First]\n            ? First extends object\n                ? First\n                : P\n            : P\n    : T extends Definition\n        ? AssignableProps<InferSchemaInstanceType<T>>\n        : never;\n\n// Helper type to determine if InitProps should be required\ntype IsInitPropsRequired<T> = T extends { initialize: (props: any) => void }\n    ? true\n    : T extends { initialize: (...args: infer P) => void }\n        ? P extends readonly []\n            ? false\n            : true\n        : false;\n\nexport interface SchemaWithExtends<T extends Definition, P extends typeof Schema, > {\n    extends: <T2 extends Definition = Definition>(\n        fields: T2 & ThisType<InferSchemaInstanceType<T & T2>>,\n        name?: string\n    ) => SchemaWithExtendsConstructor<T & T2, ExtractInitProps<T2>, P>;\n}\n\n/**\n * Get the type of the schema defined via `schema({...})` method.\n *\n * @example\n * const Entity = schema({\n *     x: \"number\",\n *     y: \"number\",\n * });\n * type Entity = SchemaType<typeof Entity>;\n */\nexport type SchemaType<T extends {'~type': any}> = T['~type'];\n\nexport interface SchemaWithExtendsConstructor<\n    T extends Definition,\n    InitProps,\n    P extends typeof Schema\n> extends SchemaWithExtends<T, P> {\n    '~type': InferSchemaInstanceType<T>;\n    new (...args: [InitProps] extends [never] ? [] : InitProps extends readonly any[] ? InitProps : IsInitPropsRequired<T> extends true ? [InitProps] : [InitProps?]): InferSchemaInstanceType<T> & InstanceType<P>;\n    prototype: InferSchemaInstanceType<T> & InstanceType<P> & {\n        initialize(...args: [InitProps] extends [never] ? [] : InitProps extends readonly any[] ? InitProps : [InitProps]): void;\n    };\n}\n\nexport function schema<\n    T extends Record<string, DefinitionType>,\n    P extends typeof Schema = typeof Schema\n>(\n    fieldsAndMethods: T & ThisType<InferSchemaInstanceType<T>>,\n    name?: string,\n    inherits: P = Schema as P\n): SchemaWithExtendsConstructor<T, ExtractInitProps<T>, P> {\n    const fields: any = {};\n    const methods: any = {};\n\n    const defaultValues: any = {};\n    const viewTagFields: any = {};\n\n    for (let fieldName in fieldsAndMethods) {\n        const value: any = fieldsAndMethods[fieldName] as DefinitionType;\n        if (typeof (value) === \"object\") {\n            if (value['view'] !== undefined) {\n                viewTagFields[fieldName] = (typeof (value['view']) === \"boolean\")\n                    ? DEFAULT_VIEW_TAG\n                    : value['view'];\n            }\n\n            fields[fieldName] = getNormalizedType(value);\n\n            // If no explicit default provided, handle automatic instantiation for collection types\n            if (!Object.prototype.hasOwnProperty.call(value, 'default')) {\n                // TODO: remove Array.isArray() check. Use ['array'] !== undefined only.\n                if (Array.isArray(value) || value['array'] !== undefined) {\n                    // Collection: Array → new ArraySchema()\n                    defaultValues[fieldName] = new ArraySchema();\n\n                } else if (value['map'] !== undefined) {\n                    // Collection: Map → new MapSchema()\n                    defaultValues[fieldName] = new MapSchema();\n\n                } else if (value['collection'] !== undefined) {\n                    // Collection: Collection → new CollectionSchema()\n                    defaultValues[fieldName] = new CollectionSchema();\n\n                } else if (value['set'] !== undefined) {\n                    // Collection: Set → new SetSchema()\n                    defaultValues[fieldName] = new SetSchema();\n\n                } else if (value['type'] !== undefined && Schema.is(value['type'])) {\n                    // Direct Schema type: Type → new Type()\n                    if (!value['type'].prototype.initialize || value['type'].prototype.initialize.length === 0) {\n                        // only auto-initialize Schema instances if:\n                        // - they don't have an initialize method\n                        // - or initialize method doesn't accept any parameters\n                        defaultValues[fieldName] = new value['type']();\n                    }\n                }\n            } else {\n                defaultValues[fieldName] = value['default'];\n            }\n\n\n        } else if (typeof (value) === \"function\") {\n            if (Schema.is(value)) {\n                // Direct Schema type: Type → new Type()\n                if (!value.prototype.initialize || value.prototype.initialize.length === 0) {\n                    // only auto-initialize Schema instances if:\n                    // - they don't have an initialize method\n                    // - or initialize method doesn't accept any parameters\n                    defaultValues[fieldName] = new value();\n                }\n                fields[fieldName] = getNormalizedType(value);\n            } else {\n                methods[fieldName] = value;\n            }\n\n        } else {\n            fields[fieldName] = getNormalizedType(value);\n        }\n    }\n\n    const getDefaultValues = () => {\n        const defaults: any = {};\n\n        // use current class default values\n        for (const fieldName in defaultValues) {\n            const defaultValue = defaultValues[fieldName];\n            if (defaultValue && typeof defaultValue.clone === 'function') {\n                // complex, cloneable values, e.g. Schema, ArraySchema, MapSchema, CollectionSchema, SetSchema\n                defaults[fieldName] = defaultValue.clone();\n            } else {\n                // primitives and non-cloneable values\n                defaults[fieldName] = defaultValue;\n            }\n        }\n        return defaults;\n    };\n\n    const getParentProps = (props: any) => {\n        const fieldNames = Object.keys(fields);\n        const parentProps: any = {};\n        for (const key in props) {\n            if (!fieldNames.includes(key)) {\n                parentProps[key] = props[key];\n            }\n        }\n        return parentProps;\n    }\n\n    /** @codegen-ignore */\n    const klass = Metadata.setFields<any>(class extends (inherits as any) {\n        constructor(...args: any[]) {\n            // call initialize method\n            if (methods.initialize && typeof methods.initialize === 'function') {\n                super(Object.assign({}, getDefaultValues(), getParentProps(args[0] || {})));\n                /**\n                 * only call initialize() in the current class, not the parent ones.\n                 * see \"should not call initialize automatically when creating an instance of inherited Schema\"\n                 */\n                if (new.target === klass) {\n                    methods.initialize.apply(this, args);\n                }\n\n            } else {\n                super(Object.assign({}, getDefaultValues(), args[0] || {}));\n            }\n        }\n    }, fields) as SchemaWithExtendsConstructor<T, ExtractInitProps<T>, P>;\n\n    // Store the getDefaultValues function on the class for inheritance\n    (klass as any)._getDefaultValues = getDefaultValues;\n\n    // Add methods to the prototype\n    Object.assign(klass.prototype, methods);\n\n    for (let fieldName in viewTagFields) {\n        view(viewTagFields[fieldName])(klass.prototype, fieldName);\n    }\n\n    if (name) {\n        Object.defineProperty(klass, \"name\", { value: name });\n    }\n\n    klass.extends = <T2 extends Definition = Definition>(fields: T2, name?: string) =>\n        schema<T2>(fields, name, klass as any) as SchemaWithExtendsConstructor<T & T2, ExtractInitProps<T2>, P>;\n\n    return klass;\n}\n"]}
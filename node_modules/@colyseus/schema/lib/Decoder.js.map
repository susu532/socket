{"version":3,"file":"Decoder.js","sourceRoot":"","sources":["../src/Decoder.ts"],"names":[],"mappings":"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","sourcesContent":["import { Metadata } from \"./Metadata\";\nimport { TypeContext } from \"./annotations\";\nimport { $childType, $decoder } from \"./changes/consts\";\nimport { DataChange, Schema, SchemaDecoderCallbacks } from \"./Schema\";\nimport { CollectionSchema } from \"./types/CollectionSchema\";\nimport { MapSchema } from \"./types/MapSchema\";\nimport { SetSchema } from \"./types/SetSchema\";\nimport { ArraySchema } from \"./types/ArraySchema\";\n\nimport * as decode from \"./encoding/decode\";\nimport { getType } from './types/typeRegistry';\nimport { SWITCH_TO_STRUCTURE, TYPE_ID, OPERATION } from './spec';\nimport { Ref } from \"./changes/ChangeTree\";\nimport { Iterator } from \"./encoding/decode\";\nimport { ReferenceTracker } from \"./changes/ReferenceTracker\";\nimport { DecodeState } from \"./changes/DecodeOperation\";\n\nexport class Decoder<T extends Schema = any> {\n    context: TypeContext;\n\n    root: T;\n    refs: ReferenceTracker;\n\n    currentRefId: number = 0;\n\n    constructor(root: T, context?: TypeContext) {\n        this.setRoot(root);\n        this.context = context || new TypeContext(root.constructor as typeof Schema);\n\n        // console.log(\">>>>>>>>>>>>>>>> Decoder types\");\n        // this.context.schemas.forEach((id, schema) => {\n        //     console.log(\"type:\", id, schema.name, Object.keys(schema[Symbol.metadata]));\n        // });\n    }\n\n    protected setRoot(root: T) {\n        this.root = root;\n        this.refs = new ReferenceTracker();\n        this.refs.addRef(0, root);\n    }\n\n    decode(\n        bytes: number[],\n        it: Iterator = { offset: 0 },\n        ref: Ref = this.root,\n    ) {\n        // console.log(\"------------------- DECODE -------------------\");\n        const allChanges: DataChange[] = [];\n\n        const $root = this.refs;\n        const totalBytes = bytes.length;\n\n        this.currentRefId = 0;\n\n        while (it.offset < totalBytes) {\n            //\n            // Peek ahead, check if it's a switch to a different structure\n            //\n            if (bytes[it.offset] == SWITCH_TO_STRUCTURE) {\n                it.offset++;\n\n                this.currentRefId = decode.number(bytes, it);\n                const nextRef = $root.refs.get(this.currentRefId) as Schema;\n\n                //\n                // Trying to access a reference that haven't been decoded yet.\n                //\n                if (!nextRef) { throw new Error(`\"refId\" not found: ${this.currentRefId}`); }\n                ref = nextRef;\n\n                continue;\n            }\n\n            const decoder = ref['constructor'][$decoder];\n            const result = decoder(this, bytes, it, ref, allChanges);\n\n            if (result === DecodeState.DEFINITION_MISMATCH) {\n                console.warn(\"@colyseus/schema: definition mismatch\");\n\n                //\n                // keep skipping next bytes until reaches a known structure\n                // by local decoder.\n                //\n                const nextIterator: decode.Iterator = { offset: it.offset };\n                while (it.offset < totalBytes) {\n                    if (decode.switchStructureCheck(bytes, it)) {\n                        nextIterator.offset = it.offset + 1;\n                        if ($root.refs.has(decode.number(bytes, nextIterator))) {\n                            break;\n                        }\n                    }\n\n                    it.offset++;\n                }\n                continue;\n            }\n        }\n\n        // FIXME: trigger callbacks\n        // this._triggerChanges(allChanges);\n\n        // drop references of unused schemas\n        $root.garbageCollectDeletedRefs();\n\n        return allChanges;\n    }\n\n    /*\n    private _triggerChanges(changes: DataChange[]) {\n        const uniqueRefIds = new Set<number>();\n        const $refs = this.refs.refs;\n\n        for (let i = 0; i < changes.length; i++) {\n            const change = changes[i];\n            const refId = change.refId;\n            const ref = $refs.get(refId);\n            const $callbacks: Schema['$callbacks'] | SchemaDecoderCallbacks['$callbacks'] = ref['$callbacks'];\n\n            //\n            // trigger onRemove on child structure.\n            //\n            if (\n                (change.op & OPERATION.DELETE) === OPERATION.DELETE &&\n                change.previousValue instanceof Schema\n            ) {\n                change.previousValue['$callbacks']?.[OPERATION.DELETE]?.forEach(callback => callback());\n            }\n\n            // no callbacks defined, skip this structure!\n            if (!$callbacks) { continue; }\n\n            if (ref instanceof Schema) {\n                if (!uniqueRefIds.has(refId)) {\n                    try {\n                        // trigger onChange\n                        ($callbacks as Schema['$callbacks'])?.[OPERATION.REPLACE]?.forEach(callback =>\n                            callback());\n\n                    } catch (e) {\n                        Schema.onError(e);\n                    }\n                }\n\n                try {\n                    if ($callbacks.hasOwnProperty(change.field)) {\n                        $callbacks[change.field]?.forEach((callback) =>\n                            callback(change.value, change.previousValue));\n                    }\n\n                } catch (e) {\n                    Schema.onError(e);\n                }\n\n            } else {\n                // is a collection of items\n\n                if (change.op === OPERATION.ADD && change.previousValue === undefined) {\n                    // triger onAdd\n                    $callbacks[OPERATION.ADD]?.forEach(callback =>\n                        callback(change.value, change.dynamicIndex ?? change.field));\n\n                } else if (change.op === OPERATION.DELETE) {\n                    //\n                    // FIXME: `previousValue` should always be available.\n                    // ADD + DELETE operations are still encoding DELETE operation.\n                    //\n                    if (change.previousValue !== undefined) {\n                        // triger onRemove\n                        $callbacks[OPERATION.DELETE]?.forEach(callback =>\n                            callback(change.previousValue, change.dynamicIndex ?? change.field));\n                    }\n\n                } else if (change.op === OPERATION.DELETE_AND_ADD) {\n                    // triger onRemove\n                    if (change.previousValue !== undefined) {\n                        $callbacks[OPERATION.DELETE]?.forEach(callback =>\n                            callback(change.previousValue, change.dynamicIndex ?? change.field));\n                    }\n\n                    // triger onAdd\n                    $callbacks[OPERATION.ADD]?.forEach(callback =>\n                        callback(change.value, change.dynamicIndex ?? change.field));\n                }\n\n                // trigger onChange\n                if (change.value !== change.previousValue) {\n                    $callbacks[OPERATION.REPLACE]?.forEach(callback =>\n                        callback(change.value, change.dynamicIndex ?? change.field));\n                }\n            }\n\n            uniqueRefIds.add(refId);\n        }\n\n    }\n    */\n\n    getInstanceType(bytes: number[], it: Iterator, defaultType: typeof Schema): typeof Schema {\n        let type: typeof Schema;\n\n        if (bytes[it.offset] === TYPE_ID) {\n            it.offset++;\n            const type_id = decode.number(bytes, it);\n            type = this.context.get(type_id);\n        }\n\n        return type || defaultType;\n    }\n\n    createInstanceOfType (type: typeof Schema): Schema {\n        // let instance: Schema = new (type as any)();\n\n        // // assign root on $changes\n        // instance[$changes].root = this.root[$changes].root;\n\n        // return instance;\n        return new (type as any)();\n    }\n\n}\n\n"]}
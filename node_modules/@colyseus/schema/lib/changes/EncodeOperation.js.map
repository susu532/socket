{"version":3,"file":"EncodeOperation.js","sourceRoot":"","sources":["../../src/changes/EncodeOperation.ts"],"names":[],"mappings":";;;AAAA,kCAAoC;AACpC,qCAAoC;AACpC,wDAAgD;AAEhD,6CAA6C;AAC7C,+CAAuF;AAOvF,kDAA+C;AAU/C,SAAgB,mBAAmB,CAC/B,IAAmB,EACnB,KAAe,EACf,KAAU,EACV,KAAa,EACb,KAAsB;IAEtB,IAAA,mBAAU,EAAC,KAAK,EAAE,IAAc,EAAE,KAAK,EAAE,KAAK,CAAC,CAAC;IAEhD,MAAM,UAAU,GAAG,MAAM,CAAC,IAAc,CAAC,CAAC;IAE1C,IAAI,UAAU,EAAE,CAAC;QACb,UAAU,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;IAE7B,CAAC;SAAM,CAAC;QACJ,MAAM,IAAI,0BAAiB,CAAC,MAAM,IAAI,uBAAuB,KAAK,oBAAoB,KAAK,CAAC,WAAW,CAAC,IAAI,IAAI,KAAK,EAAE,CAAC,CAAC;IAC7H,CAAC;AACL,CAAC;AAjBD,kDAiBC;AAED,SAAgB,WAAW,CACvB,OAAgB,EAChB,KAAe,EACf,GAAW,EACX,IAAS,EACT,KAAU,EACV,KAAsB,EACtB,SAAoB;IAEpB,IAAI,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,KAAK,SAAS,EAAE,CAAC;QACtC,IAAA,2BAAkB,EAAC,KAAK,EAAE,IAAqB,EAAE,GAAa,EAAE,KAAK,CAAC,CAAC;QAEvE,EAAE;QACF,kCAAkC;QAClC,6EAA6E;QAC7E,EAAE;QACF,MAAM,CAAC,MAAM,CAAC,KAAK,EAAE,KAAK,CAAC,iBAAQ,CAAC,CAAC,KAAK,CAAC,CAAC;QAE5C,4DAA4D;QAC5D,IAAI,CAAC,SAAS,GAAG,gBAAS,CAAC,GAAG,CAAC,KAAK,gBAAS,CAAC,GAAG,EAAE,CAAC;YAChD,OAAO,CAAC,eAAe,CAAC,KAAK,EAAE,IAAqB,EAAE,KAAK,CAAC,WAA4B,CAAC,CAAC;QAC9F,CAAC;IAEL,CAAC;SAAM,IAAI,OAAO,CAAC,IAAI,CAAC,KAAK,QAAQ,EAAE,CAAC;QACpC,EAAE;QACF,mBAAmB;QACnB,EAAE;QACF,mBAAmB,CAAC,IAAqB,EAAE,KAAK,EAAE,KAAK,EAAE,GAAa,EAAE,KAAK,CAAC,CAAC;IAEnF,CAAC;SAAM,CAAC;QACJ,EAAE;QACF,4CAA4C;QAC5C,EAAE;QACF,MAAM,UAAU,GAAG,IAAA,sBAAO,EAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QAEjD,EAAE;QACF,yCAAyC;QACzC,EAAE;QACF,IAAA,2BAAkB,EAAC,GAAG,CAAC,KAAK,CAAC,EAAE,UAAU,CAAC,WAAW,EAAE,GAAa,EAAE,KAAK,CAAC,CAAC;QAE7E,EAAE;QACF,kCAAkC;QAClC,6EAA6E;QAC7E,EAAE;QACF,MAAM,CAAC,MAAM,CAAC,KAAK,EAAE,KAAK,CAAC,iBAAQ,CAAC,CAAC,KAAK,CAAC,CAAC;IAChD,CAAC;AACL,CAAC;AA9CD,kCA8CC;AAED;;;GAGG;AACI,MAAM,qBAAqB,GAAoB,UAClD,OAAgB,EAChB,KAAe,EACf,UAAyB,EACzB,KAAa,EACb,SAAoB;IAEpB,MAAM,GAAG,GAAG,UAAU,CAAC,GAAG,CAAC;IAC3B,MAAM,QAAQ,GAAG,GAAG,CAAC,aAAa,CAAC,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;IAErD,MAAM,KAAK,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAC;IAC9B,MAAM,IAAI,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC;IAClC,MAAM,KAAK,GAAG,GAAG,CAAC,KAAK,CAAC,CAAC;IAEzB,qCAAqC;IACrC,MAAM,CAAC,KAAK,CAAC,KAAK,EAAE,CAAC,KAAK,GAAG,SAAS,CAAC,CAAC,CAAC;IAEzC,6BAA6B;IAC7B,IAAI,KAAK,IAAI,KAAK,CAAC,iBAAQ,CAAC,EAAE,CAAC;QAC3B,KAAK,CAAC,iBAAQ,CAAC,CAAC,WAAW,EAAE,CAAC;IAClC,CAAC;IAED,IAAI,SAAS,KAAK,gBAAS,CAAC,KAAK,EAAE,CAAC;QAChC,OAAO;IACX,CAAC;IAED,yDAAyD;IACzD,WAAW,CAAC,OAAO,EAAE,KAAK,EAAE,GAAG,EAAE,IAAI,EAAE,KAAK,EAAE,KAAK,EAAE,SAAS,CAAC,CAAC;AACpE,CAAC,CAAA;AA5BY,QAAA,qBAAqB,yBA4BjC;AAED;;;GAGG;AACI,MAAM,uBAAuB,GAAoB,UACpD,OAAgB,EAChB,KAAe,EACf,UAAyB,EACzB,KAAa,EACb,SAAoB;IAEpB,MAAM,GAAG,GAAG,UAAU,CAAC,GAAG,CAAC;IAE3B,iCAAiC;IACjC,IAAI,SAAS,KAAK,gBAAS,CAAC,KAAK,EAAE,CAAC;QAChC,MAAM,CAAC,KAAK,CAAC,KAAK,EAAE,SAAS,CAAC,CAAC;QAE/B,oBAAoB;QACpB,IAAI,SAAS,KAAK,gBAAS,CAAC,KAAK,EAAE,CAAC;YAChC,OAAO;QACX,CAAC;QAED,qBAAqB;QACrB,MAAM,CAAC,MAAM,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;IAChC,CAAC;IAED,EAAE;IACF,2CAA2C;IAC3C,EAAE;IACF,IAAI,CAAC,SAAS,GAAG,gBAAS,CAAC,GAAG,CAAC,IAAI,gBAAS,CAAC,GAAG,EAAE,CAAC,CAAC,wBAAwB;QACxE,IAAI,GAAG,YAAY,qBAAS,EAAE,CAAC;YAC3B,EAAE;YACF,wBAAwB;YACxB,EAAE;YACF,MAAM,YAAY,GAAG,UAAU,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;YAC3D,MAAM,CAAC,MAAM,CAAC,KAAK,EAAE,YAAY,CAAC,CAAC;QACvC,CAAC;IACL,CAAC;IAED,IAAI,SAAS,KAAK,gBAAS,CAAC,MAAM,EAAE,CAAC;QACjC,EAAE;QACF,uCAAuC;QACvC,EAAE;QACF,oBAAoB;QACpB,4CAA4C;QAC5C,IAAI;QACJ,OAAO;IACX,CAAC;IAED,MAAM,IAAI,GAAG,UAAU,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;IACvC,MAAM,KAAK,GAAG,UAAU,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;IAEzC,6BAA6B;IAC7B,IAAI,KAAK,IAAI,KAAK,CAAC,iBAAQ,CAAC,EAAE,CAAC;QAC3B,KAAK,CAAC,iBAAQ,CAAC,CAAC,WAAW,EAAE,CAAC;IAClC,CAAC;IAED,IAAI,SAAS,KAAK,gBAAS,CAAC,KAAK,EAAE,CAAC;QAChC,OAAO;IACX,CAAC;IAED,yDAAyD;IACzD,WAAW,CAAC,OAAO,EAAE,KAAK,EAAE,GAAG,EAAE,IAAI,EAAE,KAAK,EAAE,KAAK,EAAE,SAAS,CAAC,CAAC;AACpE,CAAC,CAAA;AA3DY,QAAA,uBAAuB,2BA2DnC","sourcesContent":["import { OPERATION } from \"../spec\";\nimport { $changes } from \"./consts\";\nimport { getType } from \"../types/typeRegistry\";\n\nimport * as encode from \"../encoding/encode\";\nimport { EncodeSchemaError, assertInstanceType, assertType } from \"../encoding/assert\";\n\nimport type { ChangeTracker, Ref } from \"./ChangeTree\";\nimport type { Encoder } from \"../Encoder\";\nimport type { Schema } from \"../Schema\";\nimport type { PrimitiveType } from \"../annotations\";\n\nimport { MapSchema } from \"../types/MapSchema\";\n\nexport type EncodeOperation<T extends Ref = any> = (\n    encoder: Encoder,\n    bytes: number[],\n    changeTree: ChangeTracker<T>,\n    index: number,\n    operation: OPERATION,\n) => void;\n\nexport function encodePrimitiveType(\n    type: PrimitiveType,\n    bytes: number[],\n    value: any,\n    klass: Schema,\n    field: string | number,\n) {\n    assertType(value, type as string, klass, field);\n\n    const encodeFunc = encode[type as string];\n\n    if (encodeFunc) {\n        encodeFunc(bytes, value);\n\n    } else {\n        throw new EncodeSchemaError(`a '${type}' was expected, but ${value} was provided in ${klass.constructor.name}#${field}`);\n    }\n}\n\nexport function encodeValue(\n    encoder: Encoder,\n    bytes: number[],\n    ref: Schema,\n    type: any,\n    value: any,\n    field: string | number,\n    operation: OPERATION\n) {\n    if (type[Symbol.metadata] !== undefined) {\n        assertInstanceType(value, type as typeof Schema, ref as Schema, field);\n\n        //\n        // Encode refId for this instance.\n        // The actual instance is going to be encoded on next `changeTree` iteration.\n        //\n        encode.number(bytes, value[$changes].refId);\n\n        // Try to encode inherited TYPE_ID if it's an ADD operation.\n        if ((operation & OPERATION.ADD) === OPERATION.ADD) {\n            encoder.tryEncodeTypeId(bytes, type as typeof Schema, value.constructor as typeof Schema);\n        }\n\n    } else if (typeof (type) === \"string\") {\n        //\n        // Primitive values\n        //\n        encodePrimitiveType(type as PrimitiveType, bytes, value, ref as Schema, field);\n\n    } else {\n        //\n        // Custom type (MapSchema, ArraySchema, etc)\n        //\n        const definition = getType(Object.keys(type)[0]);\n\n        //\n        // ensure a ArraySchema has been provided\n        //\n        assertInstanceType(ref[field], definition.constructor, ref as Schema, field);\n\n        //\n        // Encode refId for this instance.\n        // The actual instance is going to be encoded on next `changeTree` iteration.\n        //\n        encode.number(bytes, value[$changes].refId);\n    }\n}\n\n/**\n * Used for Schema instances.\n * @private\n */\nexport const encodeSchemaOperation: EncodeOperation = function (\n    encoder: Encoder,\n    bytes: number[],\n    changeTree: ChangeTracker,\n    index: number,\n    operation: OPERATION,\n) {\n    const ref = changeTree.ref;\n    const metadata = ref['constructor'][Symbol.metadata];\n\n    const field = metadata[index];\n    const type = metadata[field].type;\n    const value = ref[field];\n\n    // \"compress\" field index + operation\n    encode.uint8(bytes, (index | operation));\n\n    // ensure refId for the value\n    if (value && value[$changes]) {\n        value[$changes].ensureRefId();\n    }\n\n    if (operation === OPERATION.TOUCH) {\n        return;\n    }\n\n    // TODO: inline this function call small performance gain\n    encodeValue(encoder, bytes, ref, type, value, field, operation);\n}\n\n/**\n * Used for collections (MapSchema, ArraySchema, etc.)\n * @private\n */\nexport const encodeKeyValueOperation: EncodeOperation = function (\n    encoder: Encoder,\n    bytes: number[],\n    changeTree: ChangeTracker,\n    field: number,\n    operation: OPERATION,\n) {\n    const ref = changeTree.ref;\n\n    // encode field index + operation\n    if (operation !== OPERATION.TOUCH) {\n        encode.uint8(bytes, operation);\n\n        // custom operations\n        if (operation === OPERATION.CLEAR) {\n            return;\n        }\n\n        // indexed operations\n        encode.number(bytes, field);\n    }\n\n    //\n    // encode \"alias\" for dynamic fields (maps)\n    //\n    if ((operation & OPERATION.ADD) == OPERATION.ADD) { // ADD or DELETE_AND_ADD\n        if (ref instanceof MapSchema) {\n            //\n            // MapSchema dynamic key\n            //\n            const dynamicIndex = changeTree.ref['$indexes'].get(field);\n            encode.string(bytes, dynamicIndex);\n        }\n    }\n\n    if (operation === OPERATION.DELETE) {\n        //\n        // TODO: delete from filter cache data.\n        //\n        // if (useFilters) {\n        //     delete changeTree.caches[fieldIndex];\n        // }\n        return;\n    }\n\n    const type = changeTree.getType(field);\n    const value = changeTree.getValue(field);\n\n    // ensure refId for the value\n    if (value && value[$changes]) {\n        value[$changes].ensureRefId();\n    }\n\n    if (operation === OPERATION.TOUCH) {\n        return;\n    }\n\n    // TODO: inline this function call small performance gain\n    encodeValue(encoder, bytes, ref, type, value, field, operation);\n}"]}
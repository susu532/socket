{"version":3,"file":"DecodeOperation.js","sourceRoot":"","sources":["../../src/changes/DecodeOperation.ts"],"names":[],"mappings":"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","sourcesContent":["import { OPERATION } from \"../spec\";\nimport { Metadata } from \"../Metadata\";\nimport { DataChange, Schema, SchemaDecoderCallbacks } from \"../Schema\";\nimport type { Ref } from \"./ChangeTree\";\nimport type { Decoder } from \"../Decoder\";\nimport * as decode from \"../encoding/decode\";\nimport { getType } from \"../types/typeRegistry\";\nimport { $childType, $deleteByIndex, $getByIndex } from \"./consts\";\nimport { ArraySchema, CollectionSchema, MapSchema, SetSchema } from \"..\";\n\nexport enum DecodeState {\n    DEFINITION_MISMATCH = 0,\n}\n\nexport type DecodeOperation<T extends Schema = any> = (\n    decoder: Decoder<T>,\n    bytes: number[],\n    it: decode.Iterator,\n    ref: Ref,\n    allChanges: DataChange[],\n) => void;\n\nexport function decodeValue(decoder: Decoder, operation: OPERATION, ref: Ref, index: number, type: any, bytes: number[], it: decode.Iterator, allChanges: DataChange[]) {\n    const $root = decoder.refs;\n    const previousValue = ref[$getByIndex](index);\n\n    let value: any;\n\n    if ((operation & OPERATION.DELETE) === OPERATION.DELETE)\n    {\n        //\n        // Delete operations\n        //\n        if (operation !== OPERATION.DELETE_AND_ADD) {\n            ref[$deleteByIndex](index);\n        }\n\n        // Flag `refId` for garbage collection.\n        const previousRefId = $root.refIds.get(previousValue);\n        if (previousRefId) {\n            $root.removeRef(previousRefId);\n        }\n\n        value = null;\n\n    } else if (Schema.is(type)) {\n        const refId = decode.number(bytes, it);\n        value = $root.refs.get(refId);\n\n        if (operation !== OPERATION.REPLACE) {\n            const childType = decoder.getInstanceType(bytes, it, type);\n\n            if (!value) {\n                value = decoder.createInstanceOfType(childType);\n\n                if (previousValue) {\n                    // value.$callbacks = previousValue.$callbacks;\n                    // value.$listeners = previousValue.$listeners;\n                    const previousRefId = $root.refIds.get(previousValue);\n                    if (previousRefId && refId !== previousRefId) {\n                        $root.removeRef(previousRefId);\n                    }\n                }\n            }\n\n            // console.log(\"ADD REF!\", refId, value, \", TYPE =>\", Metadata.getFor(childType));\n            $root.addRef(refId, value, (value !== previousValue));\n        }\n\n    } else if (typeof(type) === \"string\") {\n        //\n        // primitive value (number, string, boolean, etc)\n        //\n        value = decode[type as string](bytes, it);\n\n    } else {\n        const typeDef = getType(Object.keys(type)[0]);\n        const refId = decode.number(bytes, it);\n\n        const valueRef: SchemaDecoderCallbacks = ($root.refs.has(refId))\n            ? previousValue || $root.refs.get(refId)\n            : new typeDef.constructor();\n\n        value = valueRef.clone(true);\n        value[$childType] = Object.values(type)[0]; // cache childType for ArraySchema and MapSchema\n\n        // preserve schema callbacks\n        if (previousValue) {\n            // value['$callbacks'] = previousValue['$callbacks'];\n            const previousRefId = $root.refIds.get(previousValue);\n\n            if (previousRefId && refId !== previousRefId) {\n                $root.removeRef(previousRefId);\n\n                //\n                // Trigger onRemove if structure has been replaced.\n                //\n                const entries: IterableIterator<[any, any]> = previousValue.entries();\n                let iter: IteratorResult<[any, any]>;\n                while ((iter = entries.next()) && !iter.done) {\n                    const [key, value] = iter.value;\n                    allChanges.push({\n                        refId,\n                        op: OPERATION.DELETE,\n                        field: key,\n                        value: undefined,\n                        previousValue: value,\n                    });\n                }\n\n            }\n        }\n\n        // console.log(\"ADD REF!\", { refId, value });\n        $root.addRef(refId, value, (valueRef !== previousValue));\n    }\n\n    return { value, previousValue };\n}\n\nexport const decodeSchemaOperation: DecodeOperation = function (\n    decoder: Decoder<any>,\n    bytes: number[],\n    it: decode.Iterator,\n    ref: Ref,\n    allChanges: DataChange[]\n) {\n    const first_byte = bytes[it.offset++];\n    const metadata: Metadata = ref['constructor'][Symbol.metadata];\n\n    // \"compressed\" index + operation\n    const operation = (first_byte >> 6) << 6\n    const index = first_byte % (operation || 255);\n\n    // skip early if field is not defined\n    const field = metadata[index];\n    if (field === undefined) {\n        return DecodeState.DEFINITION_MISMATCH;\n    }\n\n    const { value, previousValue } = decodeValue(\n        decoder,\n        operation,\n        ref,\n        index,\n        metadata[field].type,\n        bytes,\n        it,\n        allChanges\n    );\n\n    if (value !== null && value !== undefined) {\n        ref[field] = value;\n    }\n\n    // add change\n    if (previousValue !== value) {\n        allChanges.push({\n            refId: decoder.currentRefId,\n            op: operation,\n            field: field,\n            value,\n            previousValue,\n        });\n    }\n}\n\nexport const decodeKeyValueOperation: DecodeOperation = function (\n    decoder: Decoder<any>,\n    bytes: number[],\n    it: decode.Iterator,\n    ref: Ref,\n    allChanges: DataChange[]\n) {\n    const first_byte = bytes[it.offset++];\n\n    // \"uncompressed\" index + operation (array/map items)\n    const operation = first_byte;\n\n    if (operation === OPERATION.CLEAR) {\n        //\n        // TODO: refactor me!\n        // The `.clear()` method is calling `$root.removeRef(refId)` for\n        // each item inside this collection\n        //\n        (ref as SchemaDecoderCallbacks).clear(allChanges);\n        return;\n    }\n\n    const index = decode.number(bytes, it);\n    const type = ref[$childType];\n\n    let dynamicIndex: number | string;\n\n    if ((operation & OPERATION.ADD) === OPERATION.ADD) { // ADD or DELETE_AND_ADD\n        dynamicIndex = (ref instanceof MapSchema)\n            ? decode.string(bytes, it)\n            : index;\n        ref['setIndex'](index, dynamicIndex);\n\n    } else {\n        // here\n        dynamicIndex = ref['getIndex'](index);\n    }\n\n    const { value, previousValue } = decodeValue(\n        decoder,\n        operation,\n        ref,\n        dynamicIndex as number,\n        type,\n        bytes,\n        it,\n        allChanges\n    );\n\n    if (value !== null && value !== undefined) {\n        if (ref instanceof MapSchema) {\n            // const key = ref['$indexes'].get(field);\n            const key = dynamicIndex as string;\n\n            // ref.set(key, value);\n            ref['$items'].set(key, value);\n\n        } else if (ref instanceof ArraySchema) {\n            // const key = ref['$indexes'][field];\n            // console.log(\"SETTING FOR ArraySchema =>\", { field, key, value });\n            // ref[key] = value;\n            ref.setAt(index, value);\n\n        } else if (ref instanceof CollectionSchema) {\n            const index = ref.add(value);\n            ref['setIndex'](index, index);\n\n        } else if (ref instanceof SetSchema) {\n            const index = ref.add(value);\n            if (index !== false) {\n                ref['setIndex'](index, index);\n            }\n        }\n    }\n\n    // add change\n    if (previousValue !== value) {\n        allChanges.push({\n            refId: decoder.currentRefId,\n            op: operation,\n            field: \"\", // FIXME: remove this\n            dynamicIndex,\n            value,\n            previousValue,\n        });\n    }\n}"]}
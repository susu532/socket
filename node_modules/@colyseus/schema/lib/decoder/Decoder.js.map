{"version":3,"file":"Decoder.js","sourceRoot":"","sources":["../../src/decoder/Decoder.ts"],"names":[],"mappings":"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","sourcesContent":["import { TypeContext } from \"../types/TypeContext\";\nimport { $changes, $childType, $decoder, $onDecodeEnd } from \"../types/symbols\";\nimport { Schema } from \"../Schema\";\n\nimport { decode } from \"../encoding/decode\";\nimport { OPERATION, SWITCH_TO_STRUCTURE, TYPE_ID } from '../encoding/spec';\nimport type { Ref } from \"../encoder/ChangeTree\";\nimport type { Iterator } from \"../encoding/decode\";\nimport { ReferenceTracker } from \"./ReferenceTracker\";\nimport { DEFINITION_MISMATCH, type DataChange, type DecodeOperation } from \"./DecodeOperation\";\nimport { Collection } from \"../types/HelperTypes\";\n\nexport class Decoder<T extends Schema = any> {\n    context: TypeContext;\n\n    state: T;\n    root: ReferenceTracker;\n\n    currentRefId: number = 0;\n\n    triggerChanges?: (allChanges: DataChange[]) => void;\n\n    constructor(root: T, context?: TypeContext) {\n        this.setState(root);\n\n        this.context = context || new TypeContext(root.constructor as typeof Schema);\n\n        // console.log(\">>>>>>>>>>>>>>>> Decoder types\");\n        // this.context.schemas.forEach((id, schema) => {\n        //     console.log(\"type:\", id, schema.name, Object.keys(schema[Symbol.metadata]));\n        // });\n    }\n\n    protected setState(root: T) {\n        this.state = root;\n        this.root = new ReferenceTracker();\n        this.root.addRef(0, root);\n    }\n\n    decode(\n        bytes: Buffer,\n        it: Iterator = { offset: 0 },\n        ref: Ref = this.state,\n    ) {\n        const allChanges: DataChange[] = [];\n\n        const $root = this.root;\n        const totalBytes = bytes.byteLength;\n\n        let decoder: DecodeOperation = ref['constructor'][$decoder];\n\n        this.currentRefId = 0;\n\n        while (it.offset < totalBytes) {\n            //\n            // Peek ahead, check if it's a switch to a different structure\n            //\n            if (bytes[it.offset] == SWITCH_TO_STRUCTURE) {\n                it.offset++;\n\n                (ref as any)[$onDecodeEnd]?.()\n\n                const nextRefId = decode.number(bytes, it);\n                const nextRef = $root.refs.get(nextRefId);\n\n                //\n                // Trying to access a reference that haven't been decoded yet.\n                //\n                if (!nextRef) {\n                    // throw new Error(`\"refId\" not found: ${nextRefId}`);\n                    console.error(`\"refId\" not found: ${nextRefId}`, { previousRef: ref, previousRefId: this.currentRefId });\n                    console.warn(\"Please report this issue to the developers.\");\n                    this.skipCurrentStructure(bytes, it, totalBytes);\n\n                } else {\n                    ref = nextRef;\n                    decoder = ref.constructor[$decoder];\n                    this.currentRefId = nextRefId;\n                }\n\n                continue;\n            }\n\n            const result = decoder(this, bytes, it, ref, allChanges);\n\n            if (result === DEFINITION_MISMATCH) {\n                console.warn(\"@colyseus/schema: definition mismatch\");\n                this.skipCurrentStructure(bytes, it, totalBytes);\n                continue;\n            }\n        }\n\n        // FIXME: DRY with SWITCH_TO_STRUCTURE block.\n        (ref as any)[$onDecodeEnd]?.()\n\n        // trigger changes\n        this.triggerChanges?.(allChanges);\n\n        // drop references of unused schemas\n        $root.garbageCollectDeletedRefs();\n\n        return allChanges;\n    }\n\n    skipCurrentStructure(bytes: Buffer, it: Iterator, totalBytes: number) {\n        //\n        // keep skipping next bytes until reaches a known structure\n        // by local decoder.\n        //\n        const nextIterator: Iterator = { offset: it.offset };\n        while (it.offset < totalBytes) {\n            if (bytes[it.offset] === SWITCH_TO_STRUCTURE) {\n                nextIterator.offset = it.offset + 1;\n                if (this.root.refs.has(decode.number(bytes, nextIterator))) {\n                    break;\n                }\n            }\n            it.offset++;\n        }\n    }\n\n    getInstanceType(bytes: Buffer, it: Iterator, defaultType: typeof Schema): typeof Schema {\n        let type: typeof Schema;\n\n        if (bytes[it.offset] === TYPE_ID) {\n            it.offset++;\n            const type_id = decode.number(bytes, it);\n            type = this.context.get(type_id);\n        }\n\n        return type || defaultType;\n    }\n\n    createInstanceOfType (type: typeof Schema): Schema {\n        return new (type as any)();\n    }\n\n    removeChildRefs(ref: Collection, allChanges: DataChange[]) {\n        const needRemoveRef = typeof ((ref as any)[$childType]) !== \"string\";\n        const refId = this.root.refIds.get(ref as Ref);\n\n        ref.forEach((value: any, key: any) => {\n            allChanges.push({\n                ref: ref as Ref,\n                refId,\n                op: OPERATION.DELETE,\n                field: key,\n                value: undefined,\n                previousValue: value\n            });\n\n            if (needRemoveRef) {\n                this.root.removeRef(this.root.refIds.get(value));\n            }\n        });\n    }\n\n}\n"]}
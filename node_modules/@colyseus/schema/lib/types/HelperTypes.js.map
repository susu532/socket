{"version":3,"file":"HelperTypes.js","sourceRoot":"","sources":["../../src/types/HelperTypes.ts"],"names":[],"mappings":"","sourcesContent":["import type { Definition, DefinitionType, PrimitiveType, RawPrimitiveType } from \"../annotations\";\nimport type { Schema } from \"../Schema\";\nimport type { ArraySchema } from \"./custom/ArraySchema\";\nimport type { CollectionSchema } from \"./custom/CollectionSchema\";\nimport type { MapSchema } from \"./custom/MapSchema\";\nimport type { SetSchema } from \"./custom/SetSchema\";\n\nexport type Constructor<T = {}> = new (...args: any[]) => T;\n\nexport interface Collection<K = any, V = any, IT = V> {\n    [Symbol.iterator](): IterableIterator<IT>;\n    forEach(callback: Function): void;\n    entries(): IterableIterator<[K, V]>;\n}\n\nexport type InferValueType<T extends DefinitionType> =\n    T extends \"string\" ? string\n    : T extends \"number\" ? number\n    : T extends \"int8\" ? number\n    : T extends \"uint8\" ? number\n    : T extends \"int16\" ? number\n    : T extends \"uint16\" ? number\n    : T extends \"int32\" ? number\n    : T extends \"uint32\" ? number\n    : T extends \"int64\" ? number\n    : T extends \"uint64\" ? number\n    : T extends \"float32\" ? number\n    : T extends \"float64\" ? number\n    : T extends \"boolean\" ? boolean\n\n    // Handle { type: ... } patterns\n    : T extends { type: infer ChildType extends PrimitiveType } ? InferValueType<ChildType>\n    : T extends { type: infer ChildType extends Constructor } ? InstanceType<ChildType>\n    : T extends { type: Array<infer ChildType> } ? (ChildType extends Record<string | number, string | number> ? ChildType[keyof ChildType][] : ChildType[]) // TS ENUM\n    : T extends { type: { map: infer ChildType } } ? (ChildType extends Record<string | number, string | number> ? MapSchema<ChildType[keyof ChildType]> : MapSchema<ChildType>) // TS ENUM\n    : T extends { type: { set: infer ChildType } } ? (ChildType extends Record<string | number, string | number> ? SetSchema<ChildType[keyof ChildType]> : SetSchema<ChildType>) // TS ENUM\n    : T extends { type: { collection: infer ChildType } } ? (ChildType extends Record<string | number, string | number> ? CollectionSchema<ChildType[keyof ChildType]> : CollectionSchema<ChildType>) // TS ENUM\n    : T extends { type: infer ChildType } ? (ChildType extends Record<string | number, string | number> ? ChildType[keyof ChildType] : ChildType) // TS ENUM\n\n    // Handle direct array patterns\n    : T extends Array<infer ChildType extends Constructor> ? InstanceType<ChildType>[]\n    : T extends Array<infer ChildType extends RawPrimitiveType> ? InferValueType<ChildType>[] // primitive types\n    : T extends Array<infer ChildType> ? (ChildType extends Record<string | number, string | number> ? ChildType[keyof ChildType][] : ChildType[]) // TS ENUM\n\n    // Handle collection object patterns\n    : T extends { array: infer ChildType extends Constructor } ? InstanceType<ChildType>[]\n    : T extends { array: infer ChildType extends RawPrimitiveType } ? InferValueType<ChildType>[] // primitive types\n    : T extends { array: infer ChildType } ? (ChildType extends Record<string | number, string | number> ? ChildType[keyof ChildType][] : ChildType[]) // TS ENUM\n\n    : T extends { map: infer ChildType extends Constructor } ? MapSchema<InstanceType<ChildType>>\n    : T extends { map: infer ChildType extends RawPrimitiveType } ? MapSchema<InferValueType<ChildType>> // primitive types\n    : T extends { map: infer ChildType } ? (ChildType extends Record<string | number, string | number> ? MapSchema<ChildType[keyof ChildType]> : MapSchema<ChildType>) // TS ENUM\n\n    : T extends { set: infer ChildType extends Constructor } ? SetSchema<InstanceType<ChildType>>\n    : T extends { set: infer ChildType extends RawPrimitiveType } ? SetSchema<InferValueType<ChildType>> // primitive types\n    : T extends { set: infer ChildType } ? (ChildType extends Record<string | number, string | number> ? SetSchema<ChildType[keyof ChildType]> : SetSchema<ChildType>) // TS ENUM\n\n    : T extends { collection: infer ChildType extends Constructor } ? CollectionSchema<InstanceType<ChildType>>\n    : T extends { collection: infer ChildType extends RawPrimitiveType } ? CollectionSchema<InferValueType<ChildType>> // primitive types\n    : T extends { collection: infer ChildType } ? (ChildType extends Record<string | number, string | number> ? CollectionSchema<ChildType[keyof ChildType]> : CollectionSchema<ChildType>) // TS ENUM\n\n    // Handle direct types\n    : T extends Constructor ? InstanceType<T>\n    : T extends Record<string | number, string | number> ? T[keyof T] // TS ENUM\n    : T extends PrimitiveType ? T\n\n    : never;\n\nexport type InferSchemaInstanceType<T extends Definition> = {\n    [K in keyof T]: T[K] extends (...args: any[]) => any\n        ? (T[K] extends new (...args: any[]) => any ? InferValueType<T[K]> : T[K])\n        : InferValueType<T[K]>\n} & Schema;\n\nexport type NonFunctionProps<T> = Omit<T, {\n    [K in keyof T]: T[K] extends Function ? K : never;\n}[keyof T]>;\n\nexport type NonFunctionPropNames<T> = {\n    [K in keyof T]: T[K] extends Function ? never : K\n}[keyof T];\n\nexport type NonFunctionNonPrimitivePropNames<T> = {\n    [K in keyof T]: T[K] extends Function\n        ? never\n        : T[K] extends number | string | boolean\n            ? never\n            : K\n}[keyof T];\n\n// Helper to recursively convert Schema instances to their JSON representation\ntype ToJSONValue<U> = U extends Schema ? ToJSON<U> : U;\n\nexport type ToJSON<T> = NonFunctionProps<{\n    [K in keyof T]:\n        T[K] extends MapSchema<infer U> ? Record<string, ToJSONValue<U>>\n        : T[K] extends Map<string, infer U> ? Record<string, ToJSONValue<U>>\n        : T[K] extends ArraySchema<infer U> ? ToJSONValue<U>[]\n        : T[K] extends SetSchema<infer U> ? ToJSONValue<U>[]\n        : T[K] extends CollectionSchema<infer U> ? ToJSONValue<U>[]\n        : T[K] extends Schema ? ToJSON<T[K]>\n        : T[K]\n}>;\n\n// Helper type to check if T is exactly 'never' (meaning no InitProps was provided)\nexport type IsNever<T> = [T] extends [never] ? true : false;\n\n/**\n * Type helper for .assign() method - allows assigning values in a flexible way\n * - Primitives can be assigned directly\n * - Schema instances can be assigned from plain objects or Schema instances\n * - Collections can be assigned from their JSON representations\n */\nexport type AssignableProps<T> = {\n    [K in NonFunctionPropNames<T>]?: T[K] extends MapSchema<infer U>\n        ? MapSchema<U> | Record<string, U extends Schema ? (U | AssignableProps<U>) : U>\n        : T[K] extends ArraySchema<infer U>\n            ? ArraySchema<U> | (U extends Schema ? (U | AssignableProps<U>)[] : U[])\n            : T[K] extends SetSchema<infer U>\n                ? SetSchema<U> | Set<U> | (U extends Schema ? (U | AssignableProps<U>)[] : U[])\n                : T[K] extends CollectionSchema<infer U>\n                    ? CollectionSchema<U> | (U extends Schema ? (U | AssignableProps<U>)[] : U[])\n                    : T[K] extends Schema\n                        ? T[K] | AssignableProps<T[K]>\n                        : T[K]\n};"]}